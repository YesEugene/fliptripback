# Анализ структуры пользователей и разделения на таблицы

## Текущая ситуация

### Текущая структура

**Таблица `users`:**
- Содержит всех пользователей: `user`, `guide`, `creator`, `admin`
- Поле `role` определяет тип пользователя
- Используется для аутентификации всех типов пользователей

**Таблица `guides`:**
- Содержит профили гидов/креаторов
- Колонка `id` совпадает с `users.id` (не `user_id`)
- Содержит: `name`, `bio`, `avatar_url`, `instagram`, `facebook`, `twitter`, `linkedin`, `website`

### Как работает админ-доступ

**Вариант 1: Хардкод (AdminLoginPage.jsx)**
- Админ логинится через специальную страницу `/admin/login`
- Хардкодные credentials: `yes.stroynov@gmail.com` / `fliptrip13`
- Создается объект с `id: 'admin-1'`, `role: 'admin'`
- Сохраняется в `localStorage`, **НЕ в БД**
- Это объясняет, почему админ не видит свою запись в БД

**Вариант 2: Через обычный login (auth-login.js)**
- Админ может быть в таблице `users` с `role: 'admin'`
- Логинится через обычный `/api/auth-login`
- Получает токен и данные из БД

## Запрос пользователя

Пользователь хочет разделить на **три отдельные таблицы**:
1. **`guides`** - уже существует
2. **`users`** - уже существует (но содержит всех)
3. **`admins`** - нужно создать

## Анализ рисков

### ⚠️ Критические риски

1. **Потеря доступа админа:**
   - Если админ залогинен через хардкод (`id: 'admin-1'`), он не в БД
   - При миграции нужно создать запись в `admins` с правильным `id`
   - Или сохранить хардкод-логин как fallback

2. **Разрыв связей:**
   - `guides.id` = `users.id` (текущая структура)
   - Если переносить админов в `admins`, нужно сохранить `id` совпадающим
   - Или изменить логику связей

3. **Изменение логики аутентификации:**
   - Сейчас все логинятся через `users` таблицу
   - После разделения нужно проверять все три таблицы
   - Или оставить `users` для аутентификации, а `guides`/`admins` только для профилей

## Предлагаемая структура

### Вариант 1: Минимальные изменения (рекомендую)

**Логика:**
- `users` - остается для **всех** пользователей (аутентификация)
- `guides` - профили гидов/креаторов (дополнительные данные)
- `admins` - профили админов (дополнительные данные)

**Структура:**

**`users` (без изменений):**
- `id` (uuid, PK)
- `email` (varchar, unique)
- `password_hash` (varchar)
- `name` (varchar)
- `role` (varchar: 'user', 'guide', 'creator', 'admin')
- `is_active` (boolean)
- `created_at`, `updated_at`, `last_login`

**`guides` (уже существует):**
- `id` (uuid, PK) = `users.id` (для role='guide' или 'creator')
- `name`, `bio`, `avatar_url`, `instagram`, `facebook`, `twitter`, `linkedin`, `website`
- `created_at`, `updated_at`

**`admins` (создать новую):**
- `id` (uuid, PK) = `users.id` (для role='admin')
- `name` (varchar)
- `bio` (text, nullable)
- `avatar_url` (varchar, nullable)
- `permissions` (jsonb, nullable) - для будущих расширений
- `created_at`, `updated_at`

**Преимущества:**
- Минимальные изменения в коде
- `users` остается единой точкой аутентификации
- Профили в отдельных таблицах для расширяемости
- Не ломает текущий доступ

**Недостатки:**
- `users` все еще содержит всех (но это нормально для аутентификации)

### Вариант 2: Полное разделение (более сложно)

**Логика:**
- `users` - только обычные пользователи (role='user')
- `guides` - гиды/креаторы (role='guide'/'creator')
- `admins` - админы (role='admin')

**Проблемы:**
- Нужно менять всю логику аутентификации
- Нужно проверять все три таблицы при логине
- Высокий риск сломать доступ
- Сложная миграция данных

**Не рекомендую** из-за высокого риска.

## План миграции (Вариант 1)

### Шаг 1: Создать таблицу `admins`

```sql
CREATE TABLE IF NOT EXISTS admins (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  bio TEXT,
  avatar_url VARCHAR(500),
  permissions JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Шаг 2: Мигрировать существующих админов

```sql
-- Найти всех админов из users
INSERT INTO admins (id, name, created_at, updated_at)
SELECT 
  id,
  COALESCE(name, email) as name,
  created_at,
  updated_at
FROM users
WHERE role = 'admin'
ON CONFLICT (id) DO NOTHING;
```

### Шаг 3: Создать запись для хардкод-админа (если нужно)

Если админ залогинен через хардкод (`id: 'admin-1'`), нужно:
- Создать запись в `users` с `id = 'admin-1'` (или использовать реальный UUID)
- Создать запись в `admins` с тем же `id`

### Шаг 4: Обновить код

**Backend:**
- Создать `api/admin-profile.js` (аналогично `guide-profile.js`)
- Использовать `admins.id` = `users.id` (не `user_id`)

**Frontend:**
- Обновить страницу настроек админа для работы с `admins` таблицей

## Текущий доступ админа

**Важно:** Пользователь залогинен через хардкод (`AdminLoginPage.jsx`):
- `id: 'admin-1'` (не UUID из БД)
- Сохранен в `localStorage`
- **НЕ в БД**

**Решение:**
1. Оставить хардкод-логин как есть (fallback)
2. Или создать реальную запись в БД для этого админа
3. Обновить `AdminLoginPage.jsx` для проверки БД после хардкод-проверки

## Рекомендации

1. **Использовать Вариант 1** (минимальные изменения)
2. **Сохранить `users` для аутентификации** всех типов
3. **Создать `admins` таблицу** для профилей админов
4. **Не трогать хардкод-логин** до создания записи в БД
5. **Сначала создать таблицу и мигрировать данные**, потом обновлять код

## Порядок действий

1. ✅ Анализ (текущий этап)
2. ⏳ Создать таблицу `admins` в Supabase
3. ⏳ Мигрировать существующих админов из `users` в `admins`
4. ⏳ Создать запись для хардкод-админа (если нужно)
5. ⏳ Создать `api/admin-profile.js` (аналогично `guide-profile.js`)
6. ⏳ Обновить `AdminLoginPage.jsx` (опционально)
7. ⏳ Обновить страницу настроек админа
8. ⏳ Протестировать доступ


